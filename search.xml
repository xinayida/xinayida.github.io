<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring notes]]></title>
    <url>%2F2018%2F05%2F09%2FSpring-notes%2F</url>
    <content type="text"><![CDATA[javax.annotation.Resource和@Autowired区别 @Resource和@Autowired两者都是做bean的注入使用。 其实@Resource并不是Spring的注解，他的包是javax.annotation.Resource 需要导入。但是Spring支持该注解的注入。 共同点：两者都可以写在字段和setter方法上。两者如果都写在字段上，就不需要写写setter方法。 @Autowired @Autowired为Spring提供的注解， 需导入Package:org.springframework.beans.factory.annotation.Autowired; 只按照byType 注入。 1234567@Autowired private UserDao userDao;//用于字段上@Autowiredpublic void setUserDao(UserDao userDao) &#123;//用于属性的setter方法上 this.userDao= userDao;&#125; @Autowired注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。 如果想使用按名称装配，可以结合@Qualifier注解一起使用。 12@Autowired @Qualifier(&quot;userDao&quot;)private PersonDao personDao; @Resource @Resource默认按 byName 自动注入,由J2EE提供。 需导入Package: javax.annotation.Resource @Resource有两个中重要的属性：name和type ，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用 byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 (1). 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常; (2). 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常; (3). 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常; (4). 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； 总结 @Autowired按byType自动注入，@Resource默认按byName自动注入 一般使用@Resource，从而实现和Spring框架解耦合 转自： Link]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 基础知识]]></title>
    <url>%2F2018%2F05%2F09%2Fnotes%2F</url>
    <content type="text"><![CDATA[基础知识 值： 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; // 字符串可以通过 + 连接。 fmt.Println(&quot;go&quot; + &quot;lang&quot;) // 整数和浮点数 fmt.Println(&quot;1+1 =&quot;, 1+1) fmt.Println(&quot;7.0/3.0 =&quot;, 7.0/3.0) // 布尔型，还有你想要的逻辑运算符。 fmt.Println(true &amp;&amp; false) fmt.Println(true || false) fmt.Println(!true)&#125; 123456golang1+1 = 27.0/3.0 = 2.3333333333333335falsetruefalse 变量 var声明1个或多个变量 12var a string = &quot;initial&quot;var b, c int = 1, 2 自动推断已经初始化的变量类型 var b = true 声明变量初始值为零值 := 为初始化变量的简写 常量 const用于声明一个常量。 1234567891011121314151617181920212223242526272829// Go 支持字符、字符串、布尔和数值 _常量_ 。package mainimport &quot;fmt&quot;import &quot;math&quot;// `const` 用于声明一个常量。const s string = &quot;constant&quot;func main() &#123; fmt.Println(s) // `const` 语句可以出现在任何 `var` 语句可以出现 // 的地方 const n = 500000000 // 常数表达式可以执行任意精度的运算 const d = 3e20 / n fmt.Println(d) // 数值型常量是没有确定的类型的，直到它们被给定了一个 // 类型，比如说一次显示的类型转化。 fmt.Println(int64(d)) // 当上下文需要时，一个数可以被给定一个类型，比如 // 变量赋值或者函数调用。举个例子，这里的 `math.Sin` // 函数需要一个 `float64` 的参数。 fmt.Println(math.Sin(n))&#125; 1234constant6e+11600000000000-0.28470407323754404 类型转换 1234var a = &quot;12112133.5123123&quot;var b, _ = strconv.ParseFloat(a, 64)var c = &quot;123123&quot;var d, _ = strconv.ParseInt(a, 10, 64) 循环 12345678910111213141516171819202122232425262728// `for` 是 Go 中唯一的循环结构。这里有 `for` 循环// 的三个基本使用方式。package mainimport &quot;fmt&quot;func main() &#123; // 最常用的方式，带单个循环条件。 i := 1 for i &lt;= 3 &#123; fmt.Println(i) i = i + 1 &#125; // 经典的初始化/条件/后续形式 `for` 循环。 for j := 7; j &lt;= 9; j++ &#123; fmt.Println(j) &#125; // 不带条件的 `for` 循环将一直执行，直到在循环体内使用 // 了 `break` 或者 `return` 来跳出循环。 for &#123; fmt.Println(&quot;loop&quot;) break &#125;&#125; if/else 分支 1234567891011121314151617181920212223242526272829303132// `if` 和 `else` 分支结构在 Go 中当然是直接了当的了。package mainimport &quot;fmt&quot;func main() &#123; // 这里是一个基本的例子。 if 7%2 == 0 &#123; fmt.Println(&quot;7 is even&quot;) &#125; else &#123; fmt.Println(&quot;7 is odd&quot;) &#125; // 你可以不要 `else` 只用 `if` 语句。 if 8%4 == 0 &#123; fmt.Println(&quot;8 is divisible by 4&quot;) &#125; // 在条件语句之前可以有一个语句；任何在这里声明的变量 // 都可以在所有的条件分支中使用。 if num := 9; num &lt; 0 &#123; fmt.Println(num, &quot;is negative&quot;) &#125; else if num &lt; 10 &#123; fmt.Println(num, &quot;has 1 digit&quot;) &#125; else &#123; fmt.Println(num, &quot;has multiple digits&quot;) &#125;&#125;// 注意，在 Go 中，你可以不适用圆括号，但是花括号是需要的。 运行：go run 编译：go build 网络框架: gin]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
